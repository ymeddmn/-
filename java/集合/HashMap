HashMap
note
1、HashMap是线程不安全的
2、HashMap初始容量为16，负载因子为0.75  （扩容见下面的第四条）
3、HashMap使用的是哈希表的结构，（我们会用一个hash（object）的方法生成一个hash值，并且根据hash值来计算下标决定这个数据被放在哪一个链表中）当某一个节点的链表的长度大于一定长度的时候将这个链表转换为红黑树
即：HashMap1.7之前采用 数组+链表 实现  1.8后采用 数组+链表+红黑树的方式实现  目的是为了提高查找效率

一篇hashmap的问答文章，内容非常全：https://www.jianshu.com/p/33b25964798c
1、HashMap采用Entry数组来存储key-value，Entry是一个单向的链表，具有next指针
2、数组是用来确定元素所在链表的位置的（元素下标用元素的hash值和数组长度-1 取模得到）
3、使用数组是因为数组查询速度快
4、当容量大于 容量乘以负载因子（capacity*factor）的时候就会进行扩容（不是满了再扩容）
5、为什么扩容是2的次幂（详细原因见上面文章的 二章二节），
		目的是为了减少碰撞，避免不同的hash值计算出来的数组下标是相同的情况
			下面是具体原理比较粗略：
				我们知道计算数组下标的原理就是 hash&length-1） ，即：hash值和数组的长度减一取模
				如果数组的长度是2的次幂，那么长度减一应该是这样的
					4-1=3  对应二进制 011
					8-1=7  对应二进制 0111
					16-1=15对应二进制 01111
				所以当hash值和这样的值进行取模的时候就可以保证最大的减少出现不同的hash值计算出来的数组下标相同的情况

6、HashMap中put的过程：
	a、对key的hashcode做hash运算计算出index
	b、如果没有碰撞直接放在数组里（数组里面存放的也是Entry节点），如果碰撞了以链表的形式放在链表里
	c、如果碰撞后长度过大就转化为红黑树
	d、如果节点以及存在就替换节点数据
	e、如果长度超过临界点就resize重新分配

7、hash算法的意义 ：  把一个大范围映射到一个小范围，可以节省空间容易保存
8、为什么解决hash冲突的时候不直接使用红黑树，而是长度超过8的时候再由列表转化为红黑树
	因为红黑树是一种平衡树，需要不断的左旋右旋保证平衡，而链表不需要
	所以如果一开始就用红黑树效率会变低

9、不用红黑树，用二叉树可以吗
	可以，但是意义不大，因为二叉树不是一个平衡树（极端情况可能就是一个链表），可能并不能带了效率的提升，用二叉树还不如用链表
10、当链表转化为红黑树的时候什么时候退化为链表
	链表长度为6的时候退化为链表，中间有个7是为了避免频繁的进行链表和红黑树的转化

11、HashMap在并发编程中有什么问题（可以使用ConcurrentHashMap和HashTable代替HashMap解决并发的问题）
	a、多线程扩容引起死循环
	b、多线程put可能导致元素丢失
12、HashMap的key可以为null吗
	可以：null的时候index==0
13、一般用什么做HashMap的key
	一般用Integer、String这种不可变类当HashMap当key，String最为常用
	因为字符串是不可变的，创建的时候hashcode就被缓存了
14、用可变的类做HashMap的key有什么问题
	hashcode值可能改变，导致put进去的值，无法get出来